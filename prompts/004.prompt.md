我需要 AI 來幫忙寫 extractor

我希望的作法：
- 用 playwright mcp 來操作瀏覽器，瀏覽網站
- 針對指定的 ai assistant 寫 extract funcitons：extractChat(), extractChatList(), pure functions ，用 JS 寫（用 JS pure functions 才能直接在瀏覽器上跑）
- 然後直接使用 playwright，在當前的瀏覽器上測試 extract functions，看結果並修改，改進迭代 extract functions
- 最終成果輸出至 js file

<!-- new_session -->

# AI Assistant Page Extractor Development Prompt

## Objective
Develop **pure DOM extraction functions** for AI assistant web interfaces (Claude, ChatGPT, Gemini, Grok). These are read-only JavaScript functions that extract data from the page without performing any actions.

**Your responsibility:** Write pure JavaScript functions that **only read** the DOM and return data.

## Target Functions
```typescript
interface AssistantPageExtractor {
  // === State Detection ===
  detectLoginState(): LoginState;
  detectGenerationState(): GenerationState;
  
  // === Data Extraction ===
  extractChatList(): readonly ChatSummary[];
  extractChatDetails(): ChatDetails;
  extractCurrentStreamingMessage(): ChatMessage | null;
  
  // === Element Location (return info, don't interact) ===
  locatePromptInput(): PromptInputInfo;
  locateStopButton(): ElementInfo | null;
  locateChatInList(chatId: string): ElementInfo | null;
}
```

### Return Types
```typescript
interface LoginState {
  assistantId: 'claude' | 'chatgpt' | 'gemini' | 'grok';
  authenticated: boolean;
  defaultModelId?: string;
  availableModelIds?: string[];
  message?: string;
}

interface GenerationState {
  isGenerating: boolean;
  canStop: boolean;
  currentMessageId?: string;
}

interface PromptInputInfo {
  available: boolean;
  selector: string;
  isDisabled: boolean;
  placeholder?: string;
  submitButtonSelector?: string;
}

interface ElementInfo {
  exists: boolean;
  selector: string;
  isVisible?: boolean;
  isEnabled?: boolean;
}

interface ChatSummary {
  id: string;
  title: string;
  url: string;
  updatedAt: string;
  modelId?: string;
}

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  createdAt: string;
  contentMarkdown: string;
  contentHtml?: string;
}

interface ChatDetails {
  id: string;
  title: string;
  url: string;
  modelId?: string;
  updatedAt: string;
  messages: readonly ChatMessage[];
}
```

## Development Workflow

### Phase 1: Exploration
Navigate to the target assistant using Playwright MCP and explore:
- Login state indicators (user menu, login buttons, avatars)
- Chat list structure (selectors, data attributes, URLs)
- Message elements (roles, content, timestamps)
- Generation indicators (stop buttons, streaming states, loading spinners)
- Prompt input elements (textarea, submit button)

Use `page.evaluate()` to inspect the DOM and log findings.

### Phase 2: Develop Functions
Implement each function individually. Test using `page.evaluate()`:
- Inject the complete function
- Execute and check the result
- Refine based on findings
- Repeat until correct

### Phase 3: Refinement
Test against different scenarios:
- Empty states (no chats, logged out)
- Loading states (partial content)
- Different content types (code, images, files)
- Long chats (100+ messages)
- Error conditions (missing elements)

Add fallback selectors and handle edge cases.

### Phase 4: Create Artifact
Combine all working functions into a single JavaScript file with:
- JSDoc comments for each function
- Error handling
- Exports for different environments (module.exports, window)

## Guidelines

### Keep It Simple
- **Don't over-engineer**: Use straightforward DOM queries
- **Avoid complexity**: No unnecessary abstractions or helper classes
- **Start minimal**: Get it working first, optimize only if needed
- **Clear code**: Readable is better than clever

### Pure Functions Only
- ❌ Don't: Click, type, navigate, modify DOM
- ✅ Do: Read DOM, return data structures

### Robust Selectors
- Prefer: `[data-testid="..."]` or `[data-*]` attributes
- Fallback: Multiple selector options
- Avoid: Generated class names, fragile selectors

### Defensive Programming
- Use optional chaining: `element?.querySelector('.title')?.textContent`
- Provide defaults: `title || 'Untitled'`
- Validate data: Check for null/undefined before using
- Wrap in try-catch: Return safe defaults on errors

### Return Complete Data
Always return all expected fields, use `undefined` for missing optional fields.

## Testing Checklist

- [ ] Works when logged out
- [ ] Works with empty chat list
- [ ] Works with typical content (10-20 items)
- [ ] Works with large content (100+ items)
- [ ] Returns correct data types
- [ ] Handles missing elements gracefully
- [ ] Has error handling
- [ ] Includes JSDoc comments

## Expected Deliverables

For each assistant:
1. **Exploration findings** - Key DOM structure insights
2. **Test results** - Successful execution of each function
3. **Final extractor file** - Complete JavaScript module

## Final File Structure

```javascript
/**
 * [Assistant Name] Page Extractor
 * Pure functions for extracting data from [assistant] web interface
 */

function detectLoginState() { /* ... */ }
function detectGenerationState() { /* ... */ }
function extractChatList() { /* ... */ }
function extractChatDetails() { /* ... */ }
function extractCurrentStreamingMessage() { /* ... */ }
function locatePromptInput() { /* ... */ }
function locateStopButton() { /* ... */ }
function locateChatInList(chatId) { /* ... */ }

// Exports
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { /* all functions */ };
}
if (typeof window !== 'undefined') {
  window.[Assistant]Extractor = { /* all functions */ };
}
```

## How to Start

When asked to develop an extractor:
1. Navigate to the target assistant website
2. Explore the DOM structure using `page.evaluate()`
3. Implement functions one by one, testing each
4. Refine based on edge cases
5. Create final artifact when all functions work

**Begin with:** "I'll develop the [assistant] page extractor. Let me explore the page structure first..."

---

**Remember:** Keep it simple. Read-only functions. Test iteratively using Playwright MCP.